#ifndef _SX_STACK_H
# define _SX_STACK_H

/***********************/
/***********************/
/***********************/
/***********************/

#endif /* _SX_STACK_H */

#if defined (SX_STACK_NAME) && defined (SX_STACK_TYPE) && defined (SX_STACK_STATES_PER_PAGE)
/*
 * one time stack template:

  (echo -e '#include <stdlib.h>\n#include "sx-pool.h"\n'; gcc -E - <sx-stack.h.gen\
    -DSX_STACK_NAME=sx\
    -DSX_STACK_TYPE="sx_t *"\
    -DSX_STACK_STATES_PER_PAGE=128\
    -DSX_STACK_ALLOCATOR=sx_pool_getmem\
    -DSX_STACK_DEALLOCATOR=sx_pool_retmem\
    -DSX_STACK_ALLOCATOR_TYPE="sx_pool_t *"\
       | sed -e '/#[[:space:]]\+[[:digit:]]\+/d' -e '$!N; /^\(\)\n\1$/!P; D' \
  ) > sx-stack.h &&\
 (gcc -E - <sx-stack.h.gen\
    -DSX_STACK_NAME=sx_str\
    -DSX_STACK_TYPE="sx_str_t *"\
    -DSX_STACK_STATES_PER_PAGE=16\
    -DSX_STACK_ALLOCATOR=sx_pool_getmem\
    -DSX_STACK_DEALLOCATOR=sx_pool_retmem\
    -DSX_STACK_ALLOCATOR_TYPE="sx_pool_t *"\
       | sed -e '/#[[:space:]]\+[[:digit:]]\+/d' -e '$!N; /^\(\)\n\1$/!P; D' \
  ) > sx-str-stack.h


 */

# ifndef SX_STACK_TYPE
#  error "no type given!"
# endif

# ifndef SX_STACK_STATES_PER_PAGE
#  error "no size given!"
# endif

# define __SX_TMP__CHUNK(__name) struct __name ## _stack_chunk
# define __SX_TMP_CHUNK(__name) __SX_TMP__CHUNK(__name)

# define __SX_TMP__PAGE(__name) struct __name ##  _stack_page
# define __SX_TMP_PAGE(__name) __SX_TMP__PAGE(__name)

# define __SX_TMP__STACK(__name) struct __name ## _stack
# define __SX_TMP_STACK(__name) __SX_TMP__STACK(__name)

# define __SX_TMP__TYPENAME(__name) __name ## _stack_t
# define __SX_TMP_TYPENAME(__name) __SX_TMP__TYPENAME(__name)

__SX_TMP_CHUNK(SX_STACK_NAME) {
  __SX_TMP_CHUNK(SX_STACK_NAME) * next;
};


__SX_TMP_PAGE(SX_STACK_NAME) {
  __SX_TMP_PAGE(SX_STACK_NAME) * prev;
  unsigned int  count;
  SX_STACK_TYPE data[SX_STACK_STATES_PER_PAGE];
};

__SX_TMP_STACK(SX_STACK_NAME) {
  __SX_TMP_PAGE(SX_STACK_NAME) * tail;

  __SX_TMP_CHUNK(SX_STACK_NAME) * free;

  SX_STACK_ALLOCATOR_TYPE allocator;
};

typedef __SX_TMP_STACK (SX_STACK_NAME) __SX_TMP_TYPENAME (SX_STACK_NAME);

# define __SX_TMP__INIT(__name) __name ## _stack_init
# define __SX_TMP_INIT(__name) __SX_TMP__INIT(__name)

static inline __SX_TMP_STACK(SX_STACK_NAME) * __SX_TMP_INIT(SX_STACK_NAME)(SX_STACK_ALLOCATOR_TYPE allocator, __SX_TMP_TYPENAME(SX_STACK_NAME) * stack)
{
  stack->tail = SX_STACK_ALLOCATOR(allocator, sizeof(__SX_TMP_PAGE(SX_STACK_NAME)));
  if (!stack->tail)
    return NULL;
  stack->tail->prev = NULL;
  stack->tail->count = 0;
  stack->free = NULL;
  stack->allocator = allocator;

  return stack;
}

# undef __SX_TMP_INIT
# undef __SX_TMP__INIT

# define __SX_TMP__PUSHN(__name) __name ## _stack_pushn
# define __SX_TMP_PUSHN(__name) __SX_TMP__PUSHN(__name)

static inline SX_STACK_TYPE* __SX_TMP_PUSHN(SX_STACK_NAME)(__SX_TMP_TYPENAME(SX_STACK_NAME) * stack)
{
  __SX_TMP_PAGE(SX_STACK_NAME) * page = NULL;

  if (!stack->tail)
    return NULL;

  if (stack->tail->count < SX_STACK_STATES_PER_PAGE) {
    return &stack->tail->data[stack->tail->count++];
  }

  /* might be allocated by previous calls */
  if (stack->free) {
    page = (__SX_TMP_PAGE(SX_STACK_NAME) *) stack->free;
    stack->free = stack->free->next;
  }

  if (!page) {
    page = SX_STACK_ALLOCATOR(stack->allocator, sizeof(__SX_TMP_PAGE(SX_STACK_NAME)));
    if (!page)
      return NULL;
  }

  page->prev = stack->tail;
  page->count = 0;
  stack->tail = page;


  return &stack->tail->data[stack->tail->count++];
}

# define __SX_TMP__PUSH(__name) __name ## _stack_push
# define __SX_TMP_PUSH(__name) __SX_TMP__PUSH(__name)

static inline SX_STACK_TYPE* __SX_TMP_PUSH(SX_STACK_NAME)(__SX_TMP_TYPENAME(SX_STACK_NAME) * stack, SX_STACK_TYPE data)
{
  SX_STACK_TYPE* d = NULL;

  d = __SX_TMP_PUSHN(SX_STACK_NAME)(stack);
  if (d)
    *d = data;

  return d;
}

# undef __SX_TMP_PUSH
# undef __SX_TMP__PUSH
# undef __SX_TMP_PUSHN
# undef __SX_TMP__PUSHN


# define __SX_TMP__TOP(__name) __name ## _stack_top
# define __SX_TMP_TOP(__name) __SX_TMP__TOP(__name)

static inline SX_STACK_TYPE __SX_TMP_TOP(SX_STACK_NAME)(__SX_TMP_TYPENAME(SX_STACK_NAME) * stack)
{
  if (!stack->tail || !stack->tail->count)
    return NULL;

  return stack->tail->data[stack->tail->count - 1];
}

# undef __SX_TMP_TOP
# undef __SX_TMP__TOP

# define __SX_TMP__POP(__name) __name ## _stack_pop
# define __SX_TMP_POP(__name) __SX_TMP__POP(__name)

static inline void __SX_TMP_POP(SX_STACK_NAME)(__SX_TMP_TYPENAME(SX_STACK_NAME) * stack)
{
  __SX_TMP_CHUNK(SX_STACK_NAME) * chunk = NULL;

  if (!stack->tail || !stack->tail->count)
    return;

  stack->tail->count--;

  if (stack->tail->prev) {
    if (!stack->tail->count) {
      chunk = (__SX_TMP_CHUNK(SX_STACK_NAME) *) stack->tail;
      stack->tail = stack->tail->prev;
    }
  }

  if (chunk) {
    chunk->next = stack->free;
    stack->free = chunk;
  }
}

# undef __SX_TMP_POP
# undef __SX_TMP__POP

# define __SX_TMP__CLEAR(__name) __name ## _stack_clear
# define __SX_TMP_CLEAR(__name) __SX_TMP__CLEAR(__name)

static inline void __SX_TMP_CLEAR(SX_STACK_NAME)(__SX_TMP_TYPENAME(SX_STACK_NAME) * stack)
{
  {
    __SX_TMP_PAGE(SX_STACK_NAME) * page = NULL;
    __SX_TMP_PAGE(SX_STACK_NAME) * prev = NULL;
    for (
         page = stack->tail, prev = page ? page->prev : NULL;
         page;
         page = prev, prev = page ? page->prev : NULL
        ) {
      SX_STACK_DEALLOCATOR(stack->allocator, page);
    }
  }
  {
    __SX_TMP_CHUNK(SX_STACK_NAME) * chunk = NULL;
    __SX_TMP_CHUNK(SX_STACK_NAME) * next = NULL;
    for (
         chunk = stack->free, next = chunk ? chunk->next : NULL;
         chunk;
         chunk = next, next = chunk ? chunk->next : NULL
        ) {
      SX_STACK_DEALLOCATOR(stack->allocator, chunk);
    }
  }
  stack->tail = NULL;
  stack->free = NULL;
}

# undef __SX_TMP_CLEAR
# undef __SX_TMP__CLEAR

# undef __SX_TMP__CHUNK
# undef __SX_TMP_CHUNK
# undef __SX_TMP__PAGE
# undef __SX_TMP_PAGE
# undef __SX_TMP__STACK
# undef __SX_TMP_STACK

#endif /* 0 */

// vim: syn=c
